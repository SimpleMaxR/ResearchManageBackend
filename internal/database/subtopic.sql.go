// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: subtopic.sql

package database

import (
	"context"
)

const createSubtopic = `-- name: CreateSubtopic :one
INSERT INTO subtopics (projectid, leaderid, enddaterequirement, disposablefunds, technicalindicators) VALUES ($1, $2, $3, $4, $5) RETURNING subtopicid
`

type CreateSubtopicParams struct {
	Projectid           int32
	Leaderid            int32
	Enddaterequirement  string
	Disposablefunds     float64
	Technicalindicators string
}

func (q *Queries) CreateSubtopic(ctx context.Context, arg CreateSubtopicParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, createSubtopic,
		arg.Projectid,
		arg.Leaderid,
		arg.Enddaterequirement,
		arg.Disposablefunds,
		arg.Technicalindicators,
	)
	var subtopicid int32
	err := row.Scan(&subtopicid)
	return subtopicid, err
}

const deleteSubtopic = `-- name: DeleteSubtopic :exec
DELETE FROM subtopics WHERE subtopicid=$1
`

func (q *Queries) DeleteSubtopic(ctx context.Context, subtopicid int32) error {
	_, err := q.db.ExecContext(ctx, deleteSubtopic, subtopicid)
	return err
}

const getSubtopic = `-- name: GetSubtopic :one
SELECT subtopicid, projectid, leaderid, enddaterequirement, disposablefunds, technicalindicators FROM subtopics WHERE subtopicid=$1
`

func (q *Queries) GetSubtopic(ctx context.Context, subtopicid int32) (Subtopic, error) {
	row := q.db.QueryRowContext(ctx, getSubtopic, subtopicid)
	var i Subtopic
	err := row.Scan(
		&i.Subtopicid,
		&i.Projectid,
		&i.Leaderid,
		&i.Enddaterequirement,
		&i.Disposablefunds,
		&i.Technicalindicators,
	)
	return i, err
}

const getSubtopicByLeader = `-- name: GetSubtopicByLeader :many
SELECT subtopicid, projectid, leaderid, enddaterequirement, disposablefunds, technicalindicators FROM subtopics WHERE leaderid=$1
`

func (q *Queries) GetSubtopicByLeader(ctx context.Context, leaderid int32) ([]Subtopic, error) {
	rows, err := q.db.QueryContext(ctx, getSubtopicByLeader, leaderid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subtopic
	for rows.Next() {
		var i Subtopic
		if err := rows.Scan(
			&i.Subtopicid,
			&i.Projectid,
			&i.Leaderid,
			&i.Enddaterequirement,
			&i.Disposablefunds,
			&i.Technicalindicators,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubtopicByProject = `-- name: GetSubtopicByProject :many
SELECT subtopicid, projectid, leaderid, enddaterequirement, disposablefunds, technicalindicators FROM subtopics WHERE projectid=$1
`

func (q *Queries) GetSubtopicByProject(ctx context.Context, projectid int32) ([]Subtopic, error) {
	rows, err := q.db.QueryContext(ctx, getSubtopicByProject, projectid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subtopic
	for rows.Next() {
		var i Subtopic
		if err := rows.Scan(
			&i.Subtopicid,
			&i.Projectid,
			&i.Leaderid,
			&i.Enddaterequirement,
			&i.Disposablefunds,
			&i.Technicalindicators,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubtopic = `-- name: UpdateSubtopic :one
UPDATE subtopics SET projectid=$2, leaderid=$3, enddaterequirement=$4, disposablefunds=$5, technicalindicators=$6 WHERE subtopicid=$1 RETURNING subtopicid, projectid, leaderid, enddaterequirement, disposablefunds, technicalindicators
`

type UpdateSubtopicParams struct {
	Subtopicid          int32
	Projectid           int32
	Leaderid            int32
	Enddaterequirement  string
	Disposablefunds     float64
	Technicalindicators string
}

func (q *Queries) UpdateSubtopic(ctx context.Context, arg UpdateSubtopicParams) (Subtopic, error) {
	row := q.db.QueryRowContext(ctx, updateSubtopic,
		arg.Subtopicid,
		arg.Projectid,
		arg.Leaderid,
		arg.Enddaterequirement,
		arg.Disposablefunds,
		arg.Technicalindicators,
	)
	var i Subtopic
	err := row.Scan(
		&i.Subtopicid,
		&i.Projectid,
		&i.Leaderid,
		&i.Enddaterequirement,
		&i.Disposablefunds,
		&i.Technicalindicators,
	)
	return i, err
}
