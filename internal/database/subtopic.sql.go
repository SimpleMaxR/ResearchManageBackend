// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: subtopic.sql

package database

import (
	"context"
)

const createSubtopic = `-- name: CreateSubtopic :one
INSERT INTO subtopics (projectid, leaderid, name, enddate, fund, tech)
VALUES ($1, $2, $3, $4, $5, $6) RETURNING subtopicid, projectid, name, leaderid, enddate, fund, tech
`

type CreateSubtopicParams struct {
	Projectid int32
	Leaderid  int32
	Name      string
	Enddate   string
	Fund      float64
	Tech      string
}

func (q *Queries) CreateSubtopic(ctx context.Context, arg CreateSubtopicParams) (Subtopic, error) {
	row := q.db.QueryRowContext(ctx, createSubtopic,
		arg.Projectid,
		arg.Leaderid,
		arg.Name,
		arg.Enddate,
		arg.Fund,
		arg.Tech,
	)
	var i Subtopic
	err := row.Scan(
		&i.Subtopicid,
		&i.Projectid,
		&i.Name,
		&i.Leaderid,
		&i.Enddate,
		&i.Fund,
		&i.Tech,
	)
	return i, err
}

const deleteSubtopic = `-- name: DeleteSubtopic :exec
DELETE FROM subtopics WHERE subtopicid = $1
`

func (q *Queries) DeleteSubtopic(ctx context.Context, subtopicid int32) error {
	_, err := q.db.ExecContext(ctx, deleteSubtopic, subtopicid)
	return err
}

const listSubtopicByLeader = `-- name: ListSubtopicByLeader :many
SELECT subtopicid, projectid, name, leaderid, enddate, fund, tech from subtopics WHERE subtopics.leaderid = $1
`

func (q *Queries) ListSubtopicByLeader(ctx context.Context, leaderid int32) ([]Subtopic, error) {
	rows, err := q.db.QueryContext(ctx, listSubtopicByLeader, leaderid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subtopic
	for rows.Next() {
		var i Subtopic
		if err := rows.Scan(
			&i.Subtopicid,
			&i.Projectid,
			&i.Name,
			&i.Leaderid,
			&i.Enddate,
			&i.Fund,
			&i.Tech,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubtopicByProject = `-- name: ListSubtopicByProject :many
SELECT subtopicid, projectid, name, leaderid, enddate, fund, tech from subtopics WHERE subtopics.projectid = $1
`

func (q *Queries) ListSubtopicByProject(ctx context.Context, projectid int32) ([]Subtopic, error) {
	rows, err := q.db.QueryContext(ctx, listSubtopicByProject, projectid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subtopic
	for rows.Next() {
		var i Subtopic
		if err := rows.Scan(
			&i.Subtopicid,
			&i.Projectid,
			&i.Name,
			&i.Leaderid,
			&i.Enddate,
			&i.Fund,
			&i.Tech,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubtopic = `-- name: UpdateSubtopic :one
UPDATE subtopics SET projectid = $1, leaderid = $2, enddate = $3, fund = $4, tech = $5, name = $6 WHERE subtopicid = $7 RETURNING subtopicid, projectid, name, leaderid, enddate, fund, tech
`

type UpdateSubtopicParams struct {
	Projectid  int32
	Leaderid   int32
	Enddate    string
	Fund       float64
	Tech       string
	Name       string
	Subtopicid int32
}

func (q *Queries) UpdateSubtopic(ctx context.Context, arg UpdateSubtopicParams) (Subtopic, error) {
	row := q.db.QueryRowContext(ctx, updateSubtopic,
		arg.Projectid,
		arg.Leaderid,
		arg.Enddate,
		arg.Fund,
		arg.Tech,
		arg.Name,
		arg.Subtopicid,
	)
	var i Subtopic
	err := row.Scan(
		&i.Subtopicid,
		&i.Projectid,
		&i.Name,
		&i.Leaderid,
		&i.Enddate,
		&i.Fund,
		&i.Tech,
	)
	return i, err
}
