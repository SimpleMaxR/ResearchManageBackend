// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: project.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const createAchievement = `-- name: CreateAchievement :one

INSERT INTO achievements (name, obtaineddate, contributorid, baseproject, basesubtopic, rank) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING achievementid
`

type CreateAchievementParams struct {
	Name          string
	Obtaineddate  time.Time
	Contributorid int32
	Baseproject   int32
	Basesubtopic  sql.NullInt32
	Rank          int32
}

// achievements
func (q *Queries) CreateAchievement(ctx context.Context, arg CreateAchievementParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, createAchievement,
		arg.Name,
		arg.Obtaineddate,
		arg.Contributorid,
		arg.Baseproject,
		arg.Basesubtopic,
		arg.Rank,
	)
	var achievementid int32
	err := row.Scan(&achievementid)
	return achievementid, err
}

const createProject = `-- name: CreateProject :one
INSERT INTO projects (peojectleader, name, researchcontent, totalfunds, startdate, enddate, qualitymonitorsid, clientid) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING projectid
`

type CreateProjectParams struct {
	Peojectleader     int32
	Name              string
	Researchcontent   sql.NullString
	Totalfunds        float64
	Startdate         time.Time
	Enddate           time.Time
	Qualitymonitorsid int32
	Clientid          int32
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, createProject,
		arg.Peojectleader,
		arg.Name,
		arg.Researchcontent,
		arg.Totalfunds,
		arg.Startdate,
		arg.Enddate,
		arg.Qualitymonitorsid,
		arg.Clientid,
	)
	var projectid int32
	err := row.Scan(&projectid)
	return projectid, err
}

const createSubtopic = `-- name: CreateSubtopic :one

INSERT INTO subtopics (projectid, leaderid, enddaterequirement, disposablefunds, technicalindicators) VALUES ($1, $2, $3, $4, $5)
RETURNING subtopicid
`

type CreateSubtopicParams struct {
	Projectid           int32
	Leaderid            int32
	Enddaterequirement  time.Time
	Disposablefunds     float64
	Technicalindicators string
}

// Subtopic
func (q *Queries) CreateSubtopic(ctx context.Context, arg CreateSubtopicParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, createSubtopic,
		arg.Projectid,
		arg.Leaderid,
		arg.Enddaterequirement,
		arg.Disposablefunds,
		arg.Technicalindicators,
	)
	var subtopicid int32
	err := row.Scan(&subtopicid)
	return subtopicid, err
}

const deleteAchievement = `-- name: DeleteAchievement :exec
DELETE FROM achievements WHERE achievementid = $1
`

func (q *Queries) DeleteAchievement(ctx context.Context, achievementid int32) error {
	_, err := q.db.ExecContext(ctx, deleteAchievement, achievementid)
	return err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects WHERE projectid = $1
`

func (q *Queries) DeleteProject(ctx context.Context, projectid int32) error {
	_, err := q.db.ExecContext(ctx, deleteProject, projectid)
	return err
}

const deleteSubtopic = `-- name: DeleteSubtopic :exec
DELETE FROM subtopics WHERE subtopicid = $1
`

func (q *Queries) DeleteSubtopic(ctx context.Context, subtopicid int32) error {
	_, err := q.db.ExecContext(ctx, deleteSubtopic, subtopicid)
	return err
}

const linkProjectPartner = `-- name: LinkProjectPartner :exec

INSERT INTO projectpartners (projectid, partnerid) VALUES ($1, $2)
`

type LinkProjectPartnerParams struct {
	Projectid int32
	Partnerid int32
}

// ProjectPartner
func (q *Queries) LinkProjectPartner(ctx context.Context, arg LinkProjectPartnerParams) error {
	_, err := q.db.ExecContext(ctx, linkProjectPartner, arg.Projectid, arg.Partnerid)
	return err
}

const linkProjectResearcher = `-- name: LinkProjectResearcher :exec

INSERT INTO projectResearchers (projectid, researcherid, joindate, workload, disposablefunds) VALUES ($1, $2, $3, $4, $5)
`

type LinkProjectResearcherParams struct {
	Projectid       int32
	Researcherid    int32
	Joindate        time.Time
	Workload        float64
	Disposablefunds float64
}

// ProjectResearcher
func (q *Queries) LinkProjectResearcher(ctx context.Context, arg LinkProjectResearcherParams) error {
	_, err := q.db.ExecContext(ctx, linkProjectResearcher,
		arg.Projectid,
		arg.Researcherid,
		arg.Joindate,
		arg.Workload,
		arg.Disposablefunds,
	)
	return err
}

const listAchievement = `-- name: ListAchievement :many
SELECT achievementid, name, obtaineddate, contributorid, baseproject, basesubtopic, rank FROM achievements WHERE baseproject = $1
`

func (q *Queries) ListAchievement(ctx context.Context, baseproject int32) ([]Achievement, error) {
	rows, err := q.db.QueryContext(ctx, listAchievement, baseproject)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Achievement
	for rows.Next() {
		var i Achievement
		if err := rows.Scan(
			&i.Achievementid,
			&i.Name,
			&i.Obtaineddate,
			&i.Contributorid,
			&i.Baseproject,
			&i.Basesubtopic,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAchievementBySubtopic = `-- name: ListAchievementBySubtopic :many
SELECT achievementid, name, obtaineddate, contributorid, baseproject, basesubtopic, rank FROM achievements WHERE basesubtopic = $1
`

func (q *Queries) ListAchievementBySubtopic(ctx context.Context, basesubtopic sql.NullInt32) ([]Achievement, error) {
	rows, err := q.db.QueryContext(ctx, listAchievementBySubtopic, basesubtopic)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Achievement
	for rows.Next() {
		var i Achievement
		if err := rows.Scan(
			&i.Achievementid,
			&i.Name,
			&i.Obtaineddate,
			&i.Contributorid,
			&i.Baseproject,
			&i.Basesubtopic,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectAll = `-- name: ListProjectAll :many
SELECT projectid, peojectleader, name, researchcontent, totalfunds, startdate, enddate, qualitymonitorsid, clientid FROM projects
`

func (q *Queries) ListProjectAll(ctx context.Context) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, listProjectAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.Projectid,
			&i.Peojectleader,
			&i.Name,
			&i.Researchcontent,
			&i.Totalfunds,
			&i.Startdate,
			&i.Enddate,
			&i.Qualitymonitorsid,
			&i.Clientid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectPartner = `-- name: ListProjectPartner :many
SELECT partnerid, name, address, leaderid, officephone FROM partners WHERE partnerid IN (SELECT partnerid FROM projectpartners WHERE projectid = $1)
`

func (q *Queries) ListProjectPartner(ctx context.Context, projectid int32) ([]Partner, error) {
	rows, err := q.db.QueryContext(ctx, listProjectPartner, projectid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Partner
	for rows.Next() {
		var i Partner
		if err := rows.Scan(
			&i.Partnerid,
			&i.Name,
			&i.Address,
			&i.Leaderid,
			&i.Officephone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectResearcher = `-- name: ListProjectResearcher :many
SELECT researcherid, lab_id, researcher_number, name, gender, title, age, emailaddress, leader, startdate, term, researchdirection FROM researchers WHERE researcherid IN (SELECT researcherid FROM projectResearchers WHERE projectid = $1)
`

func (q *Queries) ListProjectResearcher(ctx context.Context, projectid int32) ([]Researcher, error) {
	rows, err := q.db.QueryContext(ctx, listProjectResearcher, projectid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Researcher
	for rows.Next() {
		var i Researcher
		if err := rows.Scan(
			&i.Researcherid,
			&i.LabID,
			&i.ResearcherNumber,
			&i.Name,
			&i.Gender,
			&i.Title,
			&i.Age,
			&i.Emailaddress,
			&i.Leader,
			&i.Startdate,
			&i.Term,
			&i.Researchdirection,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubtopic = `-- name: ListSubtopic :many
SELECT subtopicid, projectid, leaderid, enddaterequirement, disposablefunds, technicalindicators FROM subtopics WHERE projectid = $1
`

func (q *Queries) ListSubtopic(ctx context.Context, projectid int32) ([]Subtopic, error) {
	rows, err := q.db.QueryContext(ctx, listSubtopic, projectid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subtopic
	for rows.Next() {
		var i Subtopic
		if err := rows.Scan(
			&i.Subtopicid,
			&i.Projectid,
			&i.Leaderid,
			&i.Enddaterequirement,
			&i.Disposablefunds,
			&i.Technicalindicators,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unlinkProjectPartner = `-- name: UnlinkProjectPartner :exec
DELETE FROM projectpartners WHERE projectid = $1 AND partnerid = $2
`

type UnlinkProjectPartnerParams struct {
	Projectid int32
	Partnerid int32
}

func (q *Queries) UnlinkProjectPartner(ctx context.Context, arg UnlinkProjectPartnerParams) error {
	_, err := q.db.ExecContext(ctx, unlinkProjectPartner, arg.Projectid, arg.Partnerid)
	return err
}

const unlinkProjectResearcher = `-- name: UnlinkProjectResearcher :exec
DELETE FROM projectResearchers WHERE projectid = $1 AND researcherid = $2
`

type UnlinkProjectResearcherParams struct {
	Projectid    int32
	Researcherid int32
}

func (q *Queries) UnlinkProjectResearcher(ctx context.Context, arg UnlinkProjectResearcherParams) error {
	_, err := q.db.ExecContext(ctx, unlinkProjectResearcher, arg.Projectid, arg.Researcherid)
	return err
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects SET peojectleader = $2, name = $3, researchcontent = $4, totalfunds = $5, startdate = $6, enddate = $7, qualitymonitorsid = $8, clientid = $9 WHERE projectid = $1
RETURNING projectid, peojectleader, name, researchcontent, totalfunds, startdate, enddate, qualitymonitorsid, clientid
`

type UpdateProjectParams struct {
	Projectid         int32
	Peojectleader     int32
	Name              string
	Researchcontent   sql.NullString
	Totalfunds        float64
	Startdate         time.Time
	Enddate           time.Time
	Qualitymonitorsid int32
	Clientid          int32
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, updateProject,
		arg.Projectid,
		arg.Peojectleader,
		arg.Name,
		arg.Researchcontent,
		arg.Totalfunds,
		arg.Startdate,
		arg.Enddate,
		arg.Qualitymonitorsid,
		arg.Clientid,
	)
	var i Project
	err := row.Scan(
		&i.Projectid,
		&i.Peojectleader,
		&i.Name,
		&i.Researchcontent,
		&i.Totalfunds,
		&i.Startdate,
		&i.Enddate,
		&i.Qualitymonitorsid,
		&i.Clientid,
	)
	return i, err
}

const updateSubtopic = `-- name: UpdateSubtopic :one
UPDATE subtopics SET projectid = $2, leaderid = $3, enddaterequirement = $4, disposablefunds = $5, technicalindicators = $6 WHERE subtopicid = $1
RETURNING subtopicid, projectid, leaderid, enddaterequirement, disposablefunds, technicalindicators
`

type UpdateSubtopicParams struct {
	Subtopicid          int32
	Projectid           int32
	Leaderid            int32
	Enddaterequirement  time.Time
	Disposablefunds     float64
	Technicalindicators string
}

func (q *Queries) UpdateSubtopic(ctx context.Context, arg UpdateSubtopicParams) (Subtopic, error) {
	row := q.db.QueryRowContext(ctx, updateSubtopic,
		arg.Subtopicid,
		arg.Projectid,
		arg.Leaderid,
		arg.Enddaterequirement,
		arg.Disposablefunds,
		arg.Technicalindicators,
	)
	var i Subtopic
	err := row.Scan(
		&i.Subtopicid,
		&i.Projectid,
		&i.Leaderid,
		&i.Enddaterequirement,
		&i.Disposablefunds,
		&i.Technicalindicators,
	)
	return i, err
}
